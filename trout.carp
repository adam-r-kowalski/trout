(load "test.carp")

(use Array)
(use Test)
(use Maybe)


(deftype (ArrayIterator a) [array (Array a)])

(use ArrayIterator)

;; (definterface step
;;   (Î» [iterator] (Pair (Maybe a) iterator)))


(defmodule Array
  (defn iterator [array] (init array)))

(defmodule Array
  (defn test-create-array-iterator [test]
    (let [i (iterator [1 2 3])]
      (assert-equal test
                    (array &i)
                    &[1 2 3]
                    "create array iterator"))))


(defmodule ArrayIterator
  (defn = [a b] (= (array a) (array b))))

(defn test-array-iterator-equal [test]
  (assert-equal test
                &(iterator [1 2 3])
                &(iterator [1 2 3])
                "array iterator equal"))

(defn test-array-iterator-not-equal [test]
  (assert-not-equal test
                    &(iterator [1 2 3])
                    &(iterator [9 8 7])
                    "array iterator not equal"))


(defmodule ArrayIterator
  (defn step [a]
    (let [arr (array &a)]
      (Pair.init (first arr)
                 (iterator (suffix-array arr 1))))))

(defn test-array-iterator-step-once [test]
  (let [i (iterator [1 2 3])
        s1 (step i)]
    (assert-equal test
                  &s1
                  &(Pair.init (Just 1) (iterator [2 3]))
                  "array iterator step once")))

(defn test-array-iterator-step-twice [test]
  (let [i (iterator [1 2 3])
        s1 (step i)
        s2 (step @(Pair.b &s1))]
    (assert-equal test
                  &s2
                  &(Pair.init (Just 2) (iterator [3]))
                  "array iterator step twice")))

(defn test-array-iterator-step-thrice [test]
  (let [i (iterator [1 2 3])
        s1 (step i)
        s2 (step @(Pair.b &s1))
        s3 (step @(Pair.b &s2))]
    (assert-equal test
                  &s3
                  &(Pair.init (Just 3) (iterator []))
                  "array iterator step thrice")))

(defn test-array-iterator-step-empty [test]
  (let [i (iterator [1 2 3])
        s1 (step i)
        s2 (step @(Pair.b &s1))
        s3 (step @(Pair.b &s2))
        s4 (step @(Pair.b &s3))]
    (assert-equal test
                  &s4
                  &(Pair.init (Nothing) (iterator []))
                  "array iterator step empty")))


(defmodule ArrayIterator
  (defn step-back [a]
    (let [arr (array &a)]
      (Pair.init (last arr)
                 (iterator (prefix-array arr (dec (Array.length arr))))))))

(defn test-array-iterator-step-back-once [test]
  (let [i (iterator [1 2 3])
        s1 (step-back i)]
    (assert-equal test
                  &s1
                  &(Pair.init (Just 3) (iterator [1 2]))
                  "array iterator step back once")))

(defn test-array-iterator-step-back-twice [test]
  (let [i (iterator [1 2 3])
        s1 (step-back i)
        s2 (step-back @(Pair.b &s1))]
    (assert-equal test
                  &s2
                  &(Pair.init (Just 2) (iterator [1]))
                  "array iterator step back twice")))

(defn test-array-iterator-step-back-thrice [test]
  (let [i (iterator [1 2 3])
        s1 (step-back i)
        s2 (step-back @(Pair.b &s1))
        s3 (step-back @(Pair.b &s2))]
    (assert-equal test
                  &s3
                  &(Pair.init (Just 1) (iterator []))
                  "array iterator step back thrice")))

(defn test-array-iterator-step-back-empty [test]
  (let [i (iterator [1 2 3])
        s1 (step-back i)
        s2 (step-back @(Pair.b &s1))
        s3 (step-back @(Pair.b &s2))
        s4 (step-back @(Pair.b &s3))]
    (assert-equal test
                  &s4
                  &(Pair.init (Nothing) (iterator []))
                  "array iterator step back empty")))


(defn test-array-iterator-step-forward-and-back [test]
  (let [i (iterator [1 2 3])
        s1 (step i)
        s2 (step-back @(Pair.b &s1))]
    (assert-equal test
                  &s2
                  &(Pair.init (Just 3) (iterator [2]))
                  "array iterator step forward and back")))



(deftype (InclusiveRange a)
    [begin a
     end a])

(defn inclusive-range [begin end]
  (InclusiveRange.init begin end))

(use InclusiveRange)

(defn test-create-inclusive-range [test]
  (let [r (inclusive-range 1 10)]
    (assert-true test
                 (and (= 1 @(begin &r))
                      (= 10 @(end &r)))
                 "create inclusive range")))


(defmodule InclusiveRange
  (defn = [a b]
    (and (= (begin a) (begin b))
         (= (end a) (end b)))))

(defn test-inclusive-range-equal [test]
  (assert-equal test
                &(inclusive-range 1 10)
                &(inclusive-range 1 10)
                "inclusive range equal"))

(defn test-inclusive-range-not-equal [test]
  (assert-not-equal test
                    &(inclusive-range 1 10)
                    &(inclusive-range 40 70)
                    "inclusive range not equal"))


(defmodule InclusiveRange
  (defn step [r]
    (let [b @(begin &r)
          e @(end &r)]
      (if (> b e)
        (Pair.init (Nothing) r)
        (Pair.init (Just b) (inclusive-range (inc b) e))))))

(defn test-inclusive-range-step [test]
  (assert-equal test
                &(step (inclusive-range 6 8))
                &(Pair.init (Just 6) (inclusive-range 7 8))
                "inclusive range step"))


;; (defn fold [f z xs]
;;   (let [s (step xs)
;;         v @(Pair.a &s)]
;;     (match v
;;            (Nothing) z
;;            (Just x) (fold f (f z x) @(Pair.b &s)))))

;; (defn test-fold [test]
;;   (assert-equal test
;;                 &(fold + 0 (iterator [1 2 3]))
;;                 &6
;;                 "fold"))

;; (test-fold test)


(defn main []
  (with-test test
    (test-create-array-iterator test)
    (test-array-iterator-equal test)
    (test-array-iterator-not-equal test)
    (test-array-iterator-step-once test)
    (test-array-iterator-step-twice test)
    (test-array-iterator-step-thrice test)
    (test-array-iterator-step-empty test)
    (test-array-iterator-step-back-once test)
    (test-array-iterator-step-back-twice test)
    (test-array-iterator-step-back-thrice test)
    (test-array-iterator-step-back-empty test)
    (test-array-iterator-step-forward-and-back test)
    (test-create-inclusive-range test)
    (test-inclusive-range-equal test)
    (test-inclusive-range-not-equal test)
    (test-inclusive-range-step test)
    ))
